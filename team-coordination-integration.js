#!/usr/bin/env node
/**
 * Team Coordination Integration - Git/Slack with Universal Context Hub
 * Connects external team coordination tools with collaborative agent workspace
 * Part of LonicFLex Collaborative Workspace System
 */

const { SimplifiedExternalCoordinator } = require('./external-integrations/simplified-external-coordinator');
const { COMMUNICATION_EVENTS } = require('./collaborative-workspace-infrastructure');

/**
 * Integration patterns for external team coordination
 */
const INTEGRATION_PATTERNS = {
    git: {
        // Agent actions that trigger Git operations
        branch_creation: ['github_agent_initialized', 'feature_development_started'],
        pr_creation: ['code_implementation_complete', 'ready_for_review'],
        issue_updates: ['task_completed', 'blocker_identified', 'help_requested'],
        milestone_tracking: ['phase_completed', 'project_milestone_reached']
    },
    
    slack: {
        // Agent events that trigger Slack notifications
        status_updates: ['agent_status_update', 'milestone_reached', 'phase_completed'],
        team_alerts: ['conflict_detected', 'blocker_identified', 'help_requested'],
        coordination_messages: ['coordination_needed', 'resource_shared', 'insight_shared'],
        escalations: ['error_occurred', 'deadline_missed', 'manual_intervention_needed']
    }
};

/**
 * Message formatting templates for different coordination types
 */
const MESSAGE_TEMPLATES = {
    slack: {
        agent_status: {
            color: "#36a64f",
            title: "Agent Status Update",
            template: "ü§ñ *{agent}* is now {status}\nüìã Current task: {task}\nüìä Progress: {progress}%"
        },
        
        collaboration: {
            color: "#ff9f00", 
            title: "Agent Collaboration",
            template: "ü§ù *{agent1}* is collaborating with *{agent2}*\nüéØ Purpose: {purpose}\nüí° Insight: {insight}"
        },
        
        milestone: {
            color: "#00ff00",
            title: "Milestone Achieved", 
            template: "üéâ *Milestone Reached*: {milestone}\nüë• Team: {agents}\nüìà Progress: {progress}%\n‚è±Ô∏è Duration: {duration}"
        },
        
        conflict: {
            color: "#ff0000",
            title: "Conflict Alert",
            template: "‚ö†Ô∏è *Conflict Detected*: {conflict_type}\nüë• Involved: {agents}\nüîÑ Status: {status}\nüõ†Ô∏è Resolution: {resolution}"
        },
        
        completion: {
            color: "#0099ff",
            title: "Project Completion",
            template: "‚úÖ *Project Complete*: {project}\nüéØ Goal: {goal}\nüë• Team: {agents}\nüìä Success Rate: {success_rate}%"
        }
    },
    
    git: {
        branch_name: "context/{scope}-{agent}-{task_id}",
        pr_title: "[{agent}] {task_description}",
        pr_description: "## Agent Work Summary\n\n**Agent**: {agent}\n**Task**: {task}\n**Collaboration**: {collaborations}\n\n## Changes\n{changes}\n\n## Testing\n{testing}\n\n*Generated by LonicFLex Collaborative Workspace*",
        issue_title: "[{agent}] {issue_type}: {description}",
        commit_message: "{agent}: {task_description}\n\nCollaborative work with: {collaborating_agents}\nWorkspace: {workspace_id}"
    }
};

class TeamCoordinationIntegration {
    constructor(workspace, options = {}) {
        this.workspace = workspace;
        this.externalCoordinator = new SimplifiedExternalCoordinator({
            enableGitHub: options.enableGitHub !== false,
            enableSlack: options.enableSlack !== false,
            ...options.external
        });
        
        this.integrationActive = false;
        this.coordinationHistory = [];
        this.externalResources = new Map(); // track created external resources
        this.messageQueue = []; // queue for external notifications
        
        // Team coordination state
        this.teamChannels = new Map(); // agent -> slack channel
        this.teamBranches = new Map(); // agent -> git branch  
        this.teamMilestones = new Map(); // milestone -> status
        this.escalationPaths = new Map(); // issue type -> escalation
        
        console.log('üîó Team Coordination Integration initialized');
    }

    /**
     * Initialize team coordination with external systems
     */
    async initialize() {
        console.log('üöÄ Initializing team coordination integration...');
        
        // Initialize external coordinator
        await this.externalCoordinator.initialize();
        
        // Setup workspace event listeners
        this.setupWorkspaceEventListeners();
        
        // Setup external resource tracking
        await this.setupExternalResourceTracking();
        
        this.integrationActive = true;
        console.log('   ‚úÖ Team coordination integration active');
    }

    /**
     * Setup event listeners for workspace events that need external coordination
     */
    setupWorkspaceEventListeners() {
        console.log('üì° Setting up workspace event listeners...');
        
        // Agent status updates
        this.workspace.communicationHub.on(COMMUNICATION_EVENTS.AGENT_STATUS_UPDATE, (data) => {
            this.handleAgentStatusForTeamCoordination(data);
        });
        
        // Resource coordination
        this.workspace.communicationHub.on(COMMUNICATION_EVENTS.RESOURCE_REQUEST, (data) => {
            this.handleResourceCoordinationForTeam(data);
        });
        
        // Conflict detection
        this.workspace.communicationHub.on(COMMUNICATION_EVENTS.CONFLICT_DETECTED, (data) => {
            this.handleConflictForTeamCoordination(data);
        });
        
        // Task completion
        this.workspace.communicationHub.on(COMMUNICATION_EVENTS.TASK_COMPLETED, (data) => {
            this.handleTaskCompletionForTeam(data);
        });
        
        // Milestone reached
        this.workspace.communicationHub.on(COMMUNICATION_EVENTS.MILESTONE_REACHED, (data) => {
            this.handleMilestoneForTeamCoordination(data);
        });
        
        // Error occurred  
        this.workspace.communicationHub.on(COMMUNICATION_EVENTS.ERROR_OCCURRED, (data) => {
            this.handleErrorForTeamEscalation(data);
        });
        
        // Agent collaboration
        this.workspace.communicationHub.on('agent_collaboration', (data) => {
            this.handleAgentCollaborationForTeam(data);
        });
        
        console.log('   ‚úÖ Workspace event listeners configured');
    }

    /**
     * Setup external resource tracking for the team
     */
    async setupExternalResourceTracking() {
        console.log('üìö Setting up external resource tracking...');
        
        const projectContext = this.workspace.getSharedResource('project_context');
        
        if (this.externalCoordinator.config.enableGitHub) {
            // Create main project branch for coordination
            const mainBranchResult = await this.externalCoordinator.createGitHubBranch(
                `context/project-${this.workspace.workspaceId}`,
                {
                    description: `Collaborative workspace: ${projectContext.goal}`,
                    workspace_id: this.workspace.workspaceId,
                    team_size: projectContext.teamPlan.agents.length
                }
            );
            
            if (mainBranchResult.success) {
                this.externalResources.set('main_branch', mainBranchResult.resources.branches[0]);
                console.log(`   ‚úÖ Main project branch created: ${mainBranchResult.resources.branches[0].name}`);
            }
        }
        
        if (this.externalCoordinator.config.enableSlack) {
            // Setup main team coordination channel
            const channelResult = await this.externalCoordinator.sendSlackNotification({
                message: this.formatSlackMessage('milestone', {
                    milestone: 'Team Workspace Initialized',
                    agents: projectContext.teamPlan.agents.map(a => a.name).join(', '),
                    progress: 0,
                    duration: '0 minutes'
                }),
                channel: this.externalCoordinator.config.slack.channel
            });
            
            if (channelResult.success) {
                console.log('   ‚úÖ Team coordination channel configured');
            }
        }
    }

    /**
     * Handle agent status updates for team coordination
     */
    async handleAgentStatusForTeamCoordination(statusData) {
        const { agent, status, task, progress, resources } = statusData;
        
        // Create Git branch for agent if starting new task
        if (status === 'working' && task && this.externalCoordinator.config.enableGitHub) {
            await this.ensureAgentBranch(agent, task);
        }
        
        // Send Slack status update for major state changes
        if (['working', 'completed', 'blocked'].includes(status) && this.externalCoordinator.config.enableSlack) {
            await this.sendSlackStatusUpdate(agent, statusData);
        }
        
        // Log coordination event
        this.logCoordinationEvent('agent_status', {
            agent,
            status,
            external_actions: ['git_branch', 'slack_notification']
        });
    }

    /**
     * Ensure agent has appropriate Git branch for their work
     */
    async ensureAgentBranch(agent, task) {
        const branchKey = `${agent}_current_work`;
        
        if (this.teamBranches.has(branchKey)) {
            return; // Agent already has active branch
        }
        
        const branchName = this.formatBranchName(agent, task);
        
        const branchResult = await this.externalCoordinator.createGitHubBranch(branchName, {
            agent: agent,
            task: task,
            workspace_id: this.workspace.workspaceId,
            parent_branch: this.externalResources.get('main_branch')?.name || 'main'
        });
        
        if (branchResult.success && branchResult.resources.branches.length > 0) {
            this.teamBranches.set(branchKey, branchResult.resources.branches[0]);
            console.log(`üåø Created branch for ${agent}: ${branchName}`);
        }
    }

    /**
     * Send Slack status update
     */
    async sendSlackStatusUpdate(agent, statusData) {
        const message = this.formatSlackMessage('agent_status', {
            agent: agent,
            status: statusData.status,
            task: statusData.task || 'No current task',
            progress: statusData.progress || 0
        });
        
        const result = await this.externalCoordinator.sendSlackNotification({
            message: message,
            channel: this.externalCoordinator.config.slack.channel
        });
        
        if (result.success) {
            console.log(`üì¢ Slack status update sent for ${agent}`);
        }
    }

    /**
     * Handle agent collaboration events for team visibility
     */
    async handleAgentCollaborationForTeam(collaborationData) {
        const { agent1, agent2, collaboration_type, purpose, insight } = collaborationData;
        
        // Create Slack collaboration notification
        if (this.externalCoordinator.config.enableSlack) {
            const message = this.formatSlackMessage('collaboration', {
                agent1,
                agent2,
                purpose,
                insight: insight || 'Cross-agent coordination'
            });
            
            await this.externalCoordinator.sendSlackNotification({
                message: message,
                channel: this.externalCoordinator.config.slack.channel
            });
        }
        
        // Log collaboration in project tracking
        this.logCoordinationEvent('collaboration', {
            participants: [agent1, agent2],
            type: collaboration_type,
            external_visibility: true
        });
    }

    /**
     * Handle milestone achievements for team coordination
     */
    async handleMilestoneForTeamCoordination(milestoneData) {
        const { milestone, agents, progress, duration } = milestoneData;
        
        // Create GitHub milestone if major achievement
        if (this.externalCoordinator.config.enableGitHub && progress >= 25) {
            await this.createGitHubMilestone(milestone, progress);
        }
        
        // Send team celebration to Slack
        if (this.externalCoordinator.config.enableSlack) {
            const message = this.formatSlackMessage('milestone', {
                milestone,
                agents: agents?.join(', ') || 'Team',
                progress,
                duration: duration || 'Unknown duration'
            });
            
            await this.externalCoordinator.sendSlackNotification({
                message: message,
                channel: this.externalCoordinator.config.slack.channel
            });
        }
        
        this.teamMilestones.set(milestone, { achieved: true, timestamp: new Date() });
    }

    /**
     * Handle conflicts for team escalation
     */
    async handleConflictForTeamCoordination(conflictData) {
        const { conflict_type, involved_agents, description, severity } = conflictData;
        
        // Create GitHub issue for tracking conflict resolution
        if (this.externalCoordinator.config.enableGitHub && severity === 'high') {
            await this.createGitHubIssueForConflict(conflictData);
        }
        
        // Send Slack alert for team awareness
        if (this.externalCoordinator.config.enableSlack) {
            const message = this.formatSlackMessage('conflict', {
                conflict_type,
                agents: involved_agents?.join(', ') || 'Multiple agents',
                status: 'Active',
                resolution: 'In progress'
            });
            
            await this.externalCoordinator.sendSlackNotification({
                message: message,
                channel: this.externalCoordinator.config.slack.channel
            });
        }
    }

    /**
     * Handle task completion for team coordination
     */
    async handleTaskCompletionForTeam(completionData) {
        const { agent, task, result } = completionData;
        
        // Create PR if code-related task completion
        if (agent === 'code' && this.externalCoordinator.config.enableGitHub) {
            await this.createPRForTaskCompletion(agent, task, result);
        }
        
        // Update team progress in Slack
        if (this.externalCoordinator.config.enableSlack) {
            const progressUpdate = await this.calculateTeamProgress();
            
            if (progressUpdate.shouldNotify) {
                const message = `üéØ **Progress Update**: ${agent} completed "${task}"\nüìä Overall progress: ${progressUpdate.percentage}%`;
                
                await this.externalCoordinator.sendSlackNotification({
                    message: message,
                    channel: this.externalCoordinator.config.slack.channel
                });
            }
        }
    }

    /**
     * Create Pull Request for completed tasks
     */
    async createPRForTaskCompletion(agent, task, result) {
        const branchKey = `${agent}_current_work`;
        const agentBranch = this.teamBranches.get(branchKey);
        
        if (!agentBranch) {
            console.log(`‚ö†Ô∏è No branch found for ${agent} - cannot create PR`);
            return;
        }
        
        const prTitle = this.formatGitMessage('pr_title', { agent, task_description: task });
        const prDescription = this.formatGitMessage('pr_description', {
            agent,
            task,
            collaborations: 'Team collaboration through Universal Context',
            changes: result?.changes || 'Implementation changes',
            testing: result?.testing || 'Automated testing included'
        });
        
        // This would create actual PR through GitHub API
        console.log(`üìã Would create PR: ${prTitle} from ${agentBranch.name}`);
    }

    /**
     * Format Slack messages using templates
     */
    formatSlackMessage(messageType, data) {
        const template = MESSAGE_TEMPLATES.slack[messageType];
        if (!template) {
            return `ü§ñ ${messageType}: ${JSON.stringify(data)}`;
        }
        
        let message = template.template;
        
        // Replace placeholders with actual data
        Object.keys(data).forEach(key => {
            const placeholder = `{${key}}`;
            message = message.replace(new RegExp(placeholder, 'g'), data[key]);
        });
        
        return {
            text: message,
            attachments: [{
                color: template.color,
                title: template.title,
                text: message,
                ts: Math.floor(Date.now() / 1000)
            }]
        };
    }

    /**
     * Format Git messages using templates
     */
    formatGitMessage(messageType, data) {
        const template = MESSAGE_TEMPLATES.git[messageType];
        if (!template) {
            return `${messageType}: ${JSON.stringify(data)}`;
        }
        
        let message = template;
        
        // Replace placeholders with actual data
        Object.keys(data).forEach(key => {
            const placeholder = `{${key}}`;
            message = message.replace(new RegExp(placeholder, 'g'), data[key]);
        });
        
        return message;
    }

    /**
     * Format branch name for agent work
     */
    formatBranchName(agent, task) {
        const taskId = task.replace(/\s+/g, '-').toLowerCase().substring(0, 20);
        return `context/agent-${agent}-${taskId}`;
    }

    /**
     * Calculate team progress and determine if notification should be sent
     */
    async calculateTeamProgress() {
        const progressData = this.workspace.getSharedResource('progress_tracking');
        const overallProgress = this.workspace.calculateOverallProgress();
        
        // Notify on significant progress milestones
        const shouldNotify = overallProgress % 25 === 0 || overallProgress === 100;
        
        return {
            percentage: overallProgress,
            shouldNotify,
            details: progressData
        };
    }

    /**
     * Log coordination events for analysis and debugging
     */
    logCoordinationEvent(eventType, data) {
        const event = {
            type: eventType,
            data,
            timestamp: new Date().toISOString(),
            workspace_id: this.workspace.workspaceId
        };
        
        this.coordinationHistory.push(event);
        
        // Keep only last 100 events
        if (this.coordinationHistory.length > 100) {
            this.coordinationHistory.shift();
        }
    }

    /**
     * Get coordination summary for reporting
     */
    getCoordinationSummary() {
        return {
            workspace_id: this.workspace.workspaceId,
            integration_active: this.integrationActive,
            external_resources: Object.fromEntries(this.externalResources),
            team_branches: Object.fromEntries(this.teamBranches),
            team_milestones: Object.fromEntries(this.teamMilestones),
            coordination_events: this.coordinationHistory.length,
            github_enabled: this.externalCoordinator.config.enableGitHub,
            slack_enabled: this.externalCoordinator.config.enableSlack
        };
    }

    /**
     * Cleanup team coordination resources
     */
    async cleanup() {
        console.log('üßπ Cleaning up team coordination resources...');
        
        this.integrationActive = false;
        
        // Clean up GitHub resources if needed
        if (this.externalCoordinator.config.enableGitHub) {
            // This would clean up temporary branches, close issues, etc.
            console.log('   üåø GitHub resources cleanup (would be implemented)');
        }
        
        // Send final Slack notification
        if (this.externalCoordinator.config.enableSlack) {
            const summary = this.getCoordinationSummary();
            await this.externalCoordinator.sendSlackNotification({
                message: `üèÅ **Workspace Complete**: ${this.workspace.workspaceId}\nüìä Coordination events: ${summary.coordination_events}\nüåø Branches: ${summary.team_branches.size}`,
                channel: this.externalCoordinator.config.slack.channel
            });
        }
        
        console.log('   ‚úÖ Team coordination cleanup complete');
    }
}

module.exports = { 
    TeamCoordinationIntegration, 
    INTEGRATION_PATTERNS, 
    MESSAGE_TEMPLATES 
};

// Demo/test functionality
if (require.main === module) {
    async function demoTeamCoordination() {
        console.log('üîó Team Coordination Integration Demo\n');
        
        const { CollaborativeWorkspaceInfrastructure } = require('./collaborative-workspace-infrastructure');
        
        // Setup workspace
        const workspace = new CollaborativeWorkspaceInfrastructure({
            workspaceId: 'demo_team_coordination'
        });
        
        await workspace.initialize();
        
        // Start project
        const projectResult = await workspace.startCollaborativeProject(
            "Build team coordination system with Git and Slack integration",
            { priority: "high", team_size: 4 }
        );
        
        // Setup team coordination
        const teamCoordination = new TeamCoordinationIntegration(workspace, {
            enableGitHub: true,
            enableSlack: true
        });
        
        await teamCoordination.initialize();
        
        // Simulate some team coordination events
        console.log('\nüé≠ Simulating team coordination events...');
        
        // Agent status update
        workspace.communicationHub.emit(COMMUNICATION_EVENTS.AGENT_STATUS_UPDATE, {
            agent: 'github',
            status: 'working',
            task: 'Setup repository structure',
            progress: 25
        });
        
        // Agent collaboration
        workspace.communicationHub.emit('agent_collaboration', {
            agent1: 'github',
            agent2: 'security',
            collaboration_type: 'coordination',
            purpose: 'Repository security setup',
            insight: 'Coordinating on branch protection rules'
        });
        
        // Milestone achievement
        workspace.communicationHub.emit(COMMUNICATION_EVENTS.MILESTONE_REACHED, {
            milestone: 'Infrastructure Setup Complete',
            agents: ['github', 'security'],
            progress: 30,
            duration: '15 minutes'
        });
        
        // Get coordination summary
        const summary = teamCoordination.getCoordinationSummary();
        
        console.log('\nüìä TEAM COORDINATION SUMMARY:');
        console.log(`   Integration active: ${summary.integration_active}`);
        console.log(`   External resources: ${Object.keys(summary.external_resources).length}`);
        console.log(`   Coordination events: ${summary.coordination_events}`);
        console.log(`   GitHub enabled: ${summary.github_enabled}`);
        console.log(`   Slack enabled: ${summary.slack_enabled}`);
        
        await teamCoordination.cleanup();
        
        console.log('\n‚úÖ Team coordination integration demo complete');
    }
    
    demoTeamCoordination().catch(console.error);
}